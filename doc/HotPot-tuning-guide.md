**HotSpot虚拟机垃圾收集调优指南**

> [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)



---





# 2 Ergonomics 工效学 {#Ergonomics}

工效学是 Java 虚拟机（JVM）和垃圾回收调整（如基于行为调优）提高应用程序性能的过程



## Behavior-Based Tuning 基于行为的调优

对于并行收集器，Java SE提供了两个垃圾收集的调优参数来实现应用的特定行为：最大暂停时间以及应用吞吐量；查看并行收集器。（这两个选项在其他收集器不可以用）。请注意这些行为并不能总是得到满足。应用需要足够的堆内存来容纳所有存活的数据。此外，最小堆的大小也会妨碍这些预期标目的实现



### Maximum Pause Time Goal 最大暂停时间目标

暂停时间指的是从垃圾收集器停止应用到回收不再使用空间的时间。最大暂停时间的目的是为了限制这种暂停的最长时间。垃圾收集器会记录暂停的平均时间以及平均时间的方差。平均值的取值来自执行的开始时间，但是会经过加权处理，因此最近的暂停行为会被考虑更为重要。如果平均值加上方差大于最大暂停时间，那么垃圾收集认为最大暂停时间不会得到满足

最大暂停时间使用命令行参数-XX:MaxGCPauseMillis=<nnn>来进行指定。这表示希望垃圾收集器暂停的时间不要超过<nnn>毫秒。垃圾收集器会调整Java堆内存以及其他垃圾收集相关的参数来尝试让垃圾收集的暂停时间小于<nnn>毫秒。默认情况下，不会限制最大暂停时间。这些调节可能会导致垃圾收集更频繁，降低应用的整体吞吐量。垃圾收集器在满足最大吞吐量之前会先尝试满足最大暂停时间。但是在某些情况，最大暂停时间不会被满足



### Throughput Goal 吞吐量目标

吞吐量的衡量来自花在垃圾收集上的时间以及花在垃圾收集之外的时间（应用运行时间）。吞吐量命令行参数-XX:GCTimeRatio=<nnn>来进行指定。垃圾收集时间与应用时间的比率为1 / (1 + <nnn>)。例如，-XX:GCTimeRatio=19[ ]()表示设置的目标是垃圾收集的总时间的1/20或者5%

垃圾收集花费的时间是指花在年轻代与老年代上的总时间。如果吞吐目标没有达到，则代的大小会增加，这是为了增加应用在垃圾收集之间运行的时间



### Footprint Goal 占用空间目标

如果吞吐量以及最大暂停时间都得到了满足，那么垃圾收集器会减少堆的大小，直到无法满足其中的一个目标（总会是吞吐量）。如果目标没有被满足，那么之后就会去实现这个目标



## Tuning Strategy 调优策略

除非你知道需要的堆大于默认的最大堆大小，否则就不要为堆选择最大值。选择满足应用程序的吞吐量

堆的大小会增长或缩小来满足所选的吞吐量目标。应用行为的更改可能会导致堆增长或缩小。例如，如果应用程序开始以更高的速率进行分配，那么堆也将同步增长以保持相同的吞吐量

如果堆增长到最大大小时，还未达到吞吐量目标，那么最大堆大小对于吞吐量目标来说太小了。将最大堆大小设置为接近平台上的总物理内存，但不会导致应用进行交换（swapping）的值。再次启动应用，如果仍未达到吞吐量目标，则应用时间目标对于平台上的可用内存来说太高了

如果可以达到吞吐量目标，但是暂停时间过长了，那么请选择最大暂停时间目标。选择最大暂停时间目标可能意味着无法实现吞吐量目标，因此请选择应用程序可接受的折衷值

通常情况下，当垃圾回收器尝试去满足相互竞争的目标时，堆的大小会出现波动。即使应用已经达到了稳定状态也会这样。实现吞吐量目标（可能需要更大的堆）会与最大暂停时间以及最小占用空间（两者可能都需要小的堆）进行竞争



# 3 Generations 分代

Java SE平台的一个优势是，它对开发人员屏蔽了内存分配以及垃圾收集的的复杂度。但是，当垃圾收集成为了主要的瓶颈时，那么就有必要去了解一些隐藏的实现。垃圾收集器对应用使用对象的方式做了一些假设，这些假设反应在那些可调参数中，这些调节参数在不牺牲抽象功能的前提下，用于提高性能

当一个对象在程序运行中，任何指针都无法到达时，该对象就被视为垃圾对象。最简单的垃圾收集算法会遍历所有可到达的对象。剩下的任何对象都会被考虑为垃圾对象。这种方式的耗时跟存活对象的数量成正比，这对维护大量存活对象的应用来说是不可接受的

虚拟机包含了一些不同的垃圾回收算法，它们通过分代收集（[ ]()generational collection）来组合使用。传统的垃圾收集会检查堆中存活的每一个对象，分代收集利用从大部分应用中观察得到的几个经验属性来减少回收无用垃圾对象的工作量。观察到的属性中，最重要的是弱代假说，即大部分对象只存活很短的时间



![Description of Figure 3-1 follows](./asserts/jsgct_dt_003_alc_vs_srvng.png)

> Figure 3-1 典型的对象生命周期分布图

有些对象活得更长，因此分布会向右延伸。例如，有一些对象在初始化的时候被分配，一直活到了进程结束。在这两个极端之间有一些需要中间计算的对象存活，这里看到为初始峰值右边的块状图形。一些应用看起来有不同的分布，但是令人惊讶的是大量的进程具有这种形状。基于观察大部分对象“死得早”这一事实，让有效收集成为可能

为了优化这种情况，内存按代进行管理（内存池管理不同年龄的对象）。当每一代被填满之后，垃圾收集开始进行。大部分的对象在年轻代中进行分配，以及死在那。当年轻代被填满，会进行`minor`收集，仅仅只有年轻代的对象会被收集，其他代的垃圾不会被回收。`minor`收集可以被优化，假设弱代假说成立，那么大量位于年轻代的对象可以被回收，这种收集的成本与被收集的存活对象的数量成正比，年轻代中未存活的对象很快就会被收集。通常，在经历一次`minor`收集后，小部分存活的对象会被转移到老年代。最终，老年代会被填满，所以必须进行收集，那么会导致一次`major`收集，整个堆都会被收集。`major`收集通常会比`minor`收集持续时间更长，因为会有大量的对象涉及其中

如果[前一章节](#Ergonomics)







# 6 The Parallel Collector 并行收集器