> 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明



**7.4.2 双亲委派模型**

站在Java虚拟机的角度，只存在两种不同的类加载器：

- 一种是启动类加载器（Bootstrap ClassLoader）
- 另外一种就是其他所有的类加载器 这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader 在JDK 8及之前版本的Java中什么是三层类加载器：
- 启动类加载器（Bootstrap Class Loader） 负责加载存放在`<JAVA_HOME>\lib`目录中的类库
- 扩展类加载器（Extension Class Loader） 负责加载`<JAVA_HOME>\lib\ext`目录中的类库
- 应用程序类加载器（Application Class Loader） 负责加载用户类路径（ClassPath）上所有的类库

![类加载器双亲委派模型](images/类加载器双亲委派模型.png)

<center>类加载器双亲委派模型</center>

不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载

**7.4.3 破坏双亲委派模型**

- 继承java.lang.ClassLoader重写loadClass()方法
- 线程上下文类加载器（Thread Context ClassLoader）

通过`java.lang.Thread`类的`setContextClassLoader()`方法进行设置

如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器

例如JNDI、JDBC等都是通过SPI（Service Provider Interface，服务提供者接口）来完成加载

- 代码热部署

  > 完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹

## 12.2 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都加入了一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了

**缓存一致性（Cache Coherence）：**

在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），这种系统称为共享内存多核系统（Shared Memory Multiprocessors System）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致

![处理器、高速缓存、主内存间的交互关系](images/处理器、高速缓存、主内存间的交互关系.png)

<center>处理器、高速缓存、主内存间的交互关系</center>

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。比如：MESI等

### 12.3.1 主内存与工作内存

Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节

> 此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题
>
> 如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中是线程私有的

---

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中

> 此处的主内存与物理硬件中的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分

每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本

> 对象的引用以及线程访问对象的某个字段是有可能被复制的，但不会有虚拟机把整个对象复制一次

线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

![线程、主内存、工作内存三者的交互关系](images/线程、主内存、工作内存三者的交互关系.png)

<center>线程、主内存、工作内存三者的交互关系</center>

### 12.3.3 对于volatile型变量的特殊规则

当一个变量被定义成`volatile`之后，它将具备两项特性：

- 第一项是保证此变量对所有线程的可见性

  指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的

- 第二项是禁止指令重排序优化

  只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了

  对于`volatile`修饰的变量，赋值后会多执行一个`lock addl$0x0，(%esp)`的操作，这个操作的作用相当于一个内存屏障

  lock前缀的作用是将本处理器的缓存写入了内存，该写入动作会让别的处理器或者别的内核的缓存失效

  通过这样一个空操作，可以让`volatile`变量的修改对其他处理器立即可见

  > `addl$0x0，(%esp)`（把ESP寄存器的值加0）是一个空操作

### 12.3.4 针对long和double型变量的特殊规则

允许虚拟机将没有被`volatile`修饰的64位数据的读写操作划分为两次32位的操作来进行

即允许虚拟机实现自行选择是否要保证64位数据类型操作的原子性

对于32位的Java虚拟机，有可能存在非原子性访问的风险

> 从JDK 9起，HotSpot增加了一个实验性的参数`-XX:+AlwaysAtomicAccesses`来约束虚拟机对所有数据类型进行原子性的访问

#### 12.4.1 线程的实现

#### 4. Java线程的实现

主流Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现

以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构

所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理

所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的

### 13.2.2 线程安全的实现方法

#### 1. 互斥同步

互斥同步（Mutual Exclusion & Synchronization）是一种最常见也是最主要的并发正确性保障手段

**同步**是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用

而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式

因此互斥是因，同步是果；互斥是方法，同步是目的

---

`synchronized`关键字经过Javac编译之后，会在同步块的前后分别形成`monitorenter`和`monitorexit`这两个字节码指令，这两个字节码指令都需要一个`reference`类型的参数来指明要锁定和解锁的对象：

- 如果代码中的`synchronized`明确指定了对象参数，那就以这个对象的引用作为`reference`
- 如果没有明确指定，那将根据`synchronized`修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁

- 在执行`monitorenter`指令时，首先要去尝试获取对象的锁

  如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值加1

- 在执行`monitorexit`指令时会将锁计数器的值减1
- 一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止
- 被`synchronized`修饰的同步块对同一条线程来说是可重入的
- 被`synchronized`修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入

---

`synchronized`与`Lock`的区别：

- `synchronized`是关键字，在JVM层面实现的同步，`Lock`是接口，在类库层面实现同步

  `Lock`的实现类有`ReentrantLock`、`ReentrantReadWriteLock`等

- `Lock`应该确保在`finally`块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不
  会释放持有的锁。这一点必须由程序员自己来保证

  `synchronized`可以由Java虚拟机来确保即使出现异常，锁也能被自动释放

- 
