> 神作：[MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.im/book/5bffcbc9f265da614b11b731)  

##### 02 初识MySQL

- 查看当前服务器程序支持的存储引擎

  `show engines;`

- 创建表时指定存储引擎

  ```mysql
  CREATE TABLE 表名(
      建表语句;
  ) ENGINE = 存储引擎名称;
  ```

- 修改表的存储引擎

  ```mysql
  ALTER TABLE 表名 ENGINE = 存储引擎名称;
  ```

---

##### 03 启动选项和配置文件

- 类Unix操作系统中的配置文件

  <div align="center">
    <img src="images/mysql配置文件路径.png" height="500px" />
  </div>

  
- 查看系统变量的命令

  `show variables [like 匹配的模式];`

  例：`show variables like 'max_connections';`

---

##### 04 字符集和比较规则

- `ASCII`字符集

  共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。

  由于总共才128个字符，所以可以使用1个字节来进行编码

- `ISO 8859-1`字符集

  共收录256个字符，是在`ASCII`字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。

  它的别名叫`latin1`

- `GB2312`字符集

  收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。

  其中收录汉字6763个，其他文字符号682个。

  同时这种字符集又兼容`ASCII`字符集，所以在编码方式上显得有些奇怪：

  - 如果该字符在`ASCII`字符集中，则采用1字节编码。
  - 否则采用2字节编码。

- `GBK`字符集

  `GBK`字符集只是在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容`GB2312`。

- `utf8`字符集

  收录所有的字符，而且还在不断扩充。

  这种字符集兼容`ASCII`字符集，采用变长编码方式，编码一个字符需要使用1～4个字节。

  > utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。

- MySQL中的`utf8`和`utf8mb4`

  - `utf8mb3`：阉割过的`utf8`字符集，只使用1～3个字节表示字符。

    我们常用的字符使用1～3个字节就可以表示了

  - `utf8mb4`：正宗的`utf8`字符集，使用1～4个字节表示字符

  在`MySQL`中`utf8`是`utf8mb3`的别名。

- 查看字符集的命令

  `show (character set | charset) [like 匹配的模式];`

  > `CHARACTER SET`和`CHARSET`是同义词，用任意一个都可以

- 查看比较规则的命令

  `show collation [like 匹配的模式]`

- 比较规则的规律

  - 比较规则名称以与其关联的字符集的名称开头

  - 后边紧跟着该比较规则主要作用于哪种语言

    比如：`utf8_polish_ci`表示以波兰语的规则比较

    `utf8_general_ci`是一种通用的比较规则

  - 名称后缀意味着该比较规则是否区分语言中的重音、大小写等

    |  后缀  |       英文释义       |       描述       |
    | :----: | :------------------: | :--------------: |
    | `_ai`  | `accent insensitive` |    不区分重音    |
    | `_as`  |  `accent sensitive`  |     区分重音     |
    | `_ci`  |  `case insensitive`  |   不区分大小写   |
    | `_cs`  |   `case sensitive`   |    区分大小写    |
    | `_bin` |       `binary`       | 以二进制方式比较 |

- 4个级别的字符集和比较规则分别是

  - 服务器级别
  - 数据库级别
  - 表级别
  - 列级别

- 服务器级别的字符集和比较规则的系统变量分别是

  - `character_set_server` - 服务器级别的字符集
  - `collation_server` - 服务器级别的比较规则

- 创建数据库时指定数据库的字符集和比较规则

  `create database 数据库名 character set 字符集名称 collate 比较规则名称;`

- 修改数据库字符集和比较规则

  `alter database 数据库名 character set 字符集名称 collate 比较规则名称;`

- 当前数据库使用的字符集和比较规则的系统变量分别是

  - `character_set_database` - 当前数据库的字符集
  - `collation_database` - 当前数据库的比较规则
  >  ***character_set_database*** 和 ***collation_database*** 这两个系统变量是只读的，不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。

- 创建表时指定字符集和比较规则

  ```mysql
  CREATE TABLE 表名 (列的信息)
      [CHARACTER SET 字符集名称]
      [COLLATE 比较规则名称]
  ```

- 修改表的字符集和比较规则

  ```mysql
  ALTER TABLE 表名
      [CHARACTER SET 字符集名称]
      [COLLATE 比较规则名称]
  ```

- 创建表的时候指定列的字符集和比较规则

  ```mysql
  CREATE TABLE 表名(
      列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
      其他列...
  );
  ```

- 修改列的时候指定列的字符集和比较规则

  ```mysql
  ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
  ```

- 仅修改字符集或仅修改比较规则时的变化规则

  - 只修改字符集，则比较规则将变为修改后的字符集默认的比较规则

  - 只修改比较规则，则字符集将变为修改后的比较规则对应的字符集

- 客户端与服务端通信时字符集的转换

  |          系统变量          |                             描述                             |
  | :------------------------: | :----------------------------------------------------------: |
  |   `character_set_client`   |                 服务器解码请求时使用的字符集                 |
  | `character_set_connection` | 服务器处理请求时会把请求字符串从`character_set_client`转为`character_set_connection` |
  |  `character_set_results`   |             服务器向客户端返回数据时使用的字符集             |

  客户端一般情况下使用的字符集与操作系统一致。

  通过`set names 字符集名`语句可以将这三个系统变量的值设置成和客户端一样。

---

##### 05 InnoDB记录存储结构

- 什么是InnoDB页

  InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 ***16*** KB。也就是说从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

- InnoDB行格式的类型

  - Compact

  - Redundant

    `MySQL5.0`之前用的一种行格式

  - Dynamic

  - Compressed

- 怎么指定行格式

  - 创建表时指定

    ```mysql
    CREATE TABLE 表名 (
      列的信息
    ) ROW_FORMAT=行格式名称
    ```

  - 修改表时指定

    ```mysql
    ALTER TABLE 表名 ROW_FORMAT=行格式名称
    ```

- COMPACT行格式

  <div align="center">
    <img src="images/compact行格式.png"
  </div>

- Dynamic/Compressed行格式

  - Dynamic行格式Compact行格式相似，只不过在处理`行溢出`数据时不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

  <div align="center">
    <img src="images/dynamic行格式.png"
  </div>

  - `Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

- 行溢出

  如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。

  <div align="center">
    <img src="images/行溢出.png"
  </div>

---

##### 06 InnoDB索引页结构

- 什么是索引（INDEX）页

  专门用来存放表中记录的页

- 索引页的结构

  索引页`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能。

  <div align="center">
    <img src="images/索引页的结构.png" height="400px">
  </div>

- 索引页各个部分的含义

  | 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
  | :------------------- | :----------------- | :----------- | :----------------------- |
  | `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
  | `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
  | `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
  | `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
  | `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
  | `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
  | `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |

- 记录在页中的存储

  存储的记录会按照我们指定的`行格式`存储到`User Records`部分。

  但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一条数据大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入，需要去申请新的页。

  <div align="center">
    <img src="images/数据在页中的存储方式.png">
  </div>

- 记录头信息的结构

  <div align="center">
    <img src="images/记录头信息的结构.png" >
  </div>

- 记录头信息各个部分的含义

  | 名称           | 大小（单位：bit） | 描述                                                         |
  | :------------- | :---------------: | :----------------------------------------------------------- |
  | `预留位1`      |        `1`        | 没有使用                                                     |
  | `预留位2`      |        `1`        | 没有使用                                                     |
  | `delete_mask`  |        `1`        | 标记该记录是否被删除                                         |
  | `min_rec_mask` |        `1`        | B+树的每层非叶子节点中的最小记录都会添加该标记               |
  | `n_owned`      |        `4`        | 表示当前记录拥有的记录数                                     |
  | `heap_no`      |       `13`        | 表示当前记录在本页的位置信息                                 |
  | `record_type`  |        `3`        | 表示当前记录的类型：<br />`0`表示普通记录；<br />`1`表示B+树非叶节点记录（目录项）；<br />`2`表示最小记录；<br />`3`表示最大记录； |
  | `next_record`  |       `16`        | 表示下一条记录的相对位置                                     |

- 什么是伪记录或者虚拟记录

  InnoDB在每个页加了两条记录，一条代表最小记录，一条代表最大记录。

  这两条记录单独放在一个称为`Infimum + Supremum`的部分。

  <div align="center">
    <img src="images/伪记录结构.png" >
  </div>

  规定：最小记录的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是最大记录。

- User Records中数据的存储结构

  <div align="center">
    <img src="images/User-Records中数据存储结构.png" >
  </div>

  InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序通过`next_record`连接起来的。

  当索引页中存在多条被删除掉的记录时，会通过`next_record`将这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

- 页目录（Page Directory）的形成过程

  - 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

  - 每个组的最后一条记录（组内最大的那条记录）的头信息中的`n_owned`属性表示该组内共有几条记录。

  - 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到`页目录`中。

    页目录中的这些地址偏移量被称为`槽`（Slot）

- 记录与页目录的逻辑关系

  <div align="center">
    <img src="images/记录与页目录的逻辑关系.png" >
  </div>

- 页目录每个分组中记录条数的规定

  - 对于最小记录所在的分组只能有 ***1*** 条记录
  - 最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间
  - 剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间

- 一个数据页中查找指定主键值的记录的过程为：

  - 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
  - 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

- 什么是页面头部（Page Header）

  是`页`结构的第二部分，占用固定的`56`个字节，专门存储各种状态信息。

  比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。

- 什么是文件头部（File Header）

  存储各种页都通用的一些信息，占用固定的`38`个字节。

  比如这个页的编号，上一个页、下一个页是谁等等。

  `InnoDB`都是以页为单位存放数据的，如果数据占用的空间非常大，通过文件头部将这些数据页关联起来，所有的数据页其实是一个双链表：

  <div align="center">
    <img src="images/数据页通过双链表关联.png" >
  </div>

- 什么是文件尾部（File Trailer）

  为了检测一个页是否完整，由固定的`8`个字节组成。

  如果某页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中出问题了，所以需要对页是否完整进行校验。

  - 前4个字节代表页的校验和

    这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。

    如果出问题了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trailer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

  - 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

---

##### 07 B+树索引

- 没有索引的列怎么查找

  从第一个页沿着双向链表一直往下找，在每一个页中从`最小记录`开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。

- 建立索引的步骤

  - 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值

    在对页中的记录进行增删改操作的过程中，需要通过一些诸如移动记录的操作来始终保证这条规定一直成立，这个过程称之为`页分裂`

  - 给所有的页建一个目录项

    每个页对应一个目录项，每个目录项包括下边两个部分：

    - 页的用户记录中最小的主键值
    - 页号

  > 目录其实就是`索引`

  <div align="center">
    <img src="images/索引的建立过程.png" >
  </div>

- 目录项纪录与用户纪录的区别
  - `目录项记录`的`record_type`值是1，而普通用户记录的`record_type`值是0
  - `目录项记录`只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有`InnoDB`自己添加的隐藏列
  - 只有存储`目录项记录`的页中，主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`

  <div align="center">
    <img src="images/目录项纪录与用户纪录的区别.png" >
  </div>

- 根据主键值查找一条用户记录的步骤

  - 确定`目录项记录`页
  - 通过`目录项记录`页确定用户记录真实所在的页
  - 在真实存储用户记录的页中定位到具体的记录

- B+树的特点

  <div align="center">
    <img src="images/B+树结构.png" >
  </div>

  <div align="center">
    <img src="images/B+树.png" >
  </div>

  - 实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`或`叶节点`
  - 存放`目录项`的节点称为`非叶子节点`或者`内节点`
  - 最上面的节点称为`根节点`

- 聚族索引的特点

  - 使用记录主键值的大小进行记录和页的排序

    - 页内的记录是按照主键的大小顺序排成一个单向链表
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表

  - `B+`树的叶子节点存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）

  具有这两种特性的`B+`树称为`聚簇索引`。

  `InnoDB`存储引擎会自动的为我们创建聚簇索引。

  `聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的索引即数据，数据即索引。

- 什么是二级索引

  按照`非主键列`建立的`B+`树需要一次`回表`操作才可以定位到完整的用户记录，这种B+树被称为`二级索引`（`secondary index`）或者`辅助索引`。

- 什么是`回表`操作

  按照`非主键列`大小排序的`B+`树只能确定要查找记录的主键值，如果想根据`非主键列`的值查找到完整的用户记录，需要到`聚簇索引`中再查一遍，这个过程被称之为`回表`。

- 二级索引有什么特点

  - 使用`索引列`的大小进行记录和页的排序，即：
    - 页内的记录是按照`索引列`大的小顺序排成一个单向链表
    - 各个存放用户记录的页也是根据页中记录的`索引列`大小顺序排成一个双向链表
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的`索引列`大小顺序排成一个双向链表
  - `B+`树的叶子节点存储的并不是完整的用户记录，而只是`索引列+主键`这两个列的值
  - 目录项记录中不再是`主键+页号`的搭配，而变成了`索引列+主键+页号`的搭配

- 什么是联合索引

  同时以多个列的大小作为排序规则，即为多个列建立索引。

  联合索引其实也是一个二级索引。

- B+树索引注意事项

  - 为某个表创建一个`B+`树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个`根节点`页面。

    最开始表中没有数据的时候，每个`B+`树索引对应的`根节点`中既没有用户记录，也没有目录项记录

  - 向表中插入用户记录时，先把用户记录存储到这个`根节点`中

  - 当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页，比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。

    这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到`页a`或者`页b`中，而`根节点`便升级为存储目录项记录的页。

  一个B+树索引的根节点被创建后，便不会再移动。它的页号会被记录到数据词典中，以后需要用到这个索引时，就直接从数据字典中取出对应的`页号`，以访问它的索引。

  - 为了保证B+树同一层内节点的目录项记录除`页号`字段以外是唯一的，所以二级索引内节点的目录项纪录的内容由三部分构成：
    - 索引列的值
    - 主键值
    - 页号
  - 一个页面最少存储两条记录

- MyISAM索引方案

  - 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录。

    可以通过行号快速访问到一条记录。

    由于在插入数据的时候并没有按照主键大小排序，所以不能在这些数据上使用二分法进行查找

  - 使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的文件中。

    `MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录

  - 我们也可以对其它的列分别建立索引或者建立联合索引，原理和`InnoDB`中的索引差不多，不过在叶子节点处存储的是`相应的列 + 行号`。这些索引也全部都是`二级索引`

- 创建和删除索引

  `InnoDB`和`MyISAM`会自动为主键或者声明为`UNIQUE`的列去自动建立`B+`树索引。

  为其他的列建立索引需要显示声明。

  - 建表时创建索引语句

    ```mysql
    CREATE TALBE 表名 (
        列的信息 ··· , 
        [KEY|INDEX] 索引名 (列1,列2, ...)
    )
    ```

  - 添加索引

    ```mysql
    ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (列1,列2, ...);
    ```

  - 删除索引

    ```mysql
    ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
    ```

  > `KEY`和`INDEX`是同义词，任意选用一个就可以

---

##### 08 B+树索引的使用

- 索引的代价

  - 空间上的代价

    每建立一个索引都要为它建立一棵`B+`树，每一棵`B+`树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的`B+`树由许多数据页组成，会占很大的一片存储空间

  - 时间上的代价

    每次对表中的数据进行增、删、改操作时，都需要去修改各个`B+`树索引。

    `B+`树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（即不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。

    而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护节点和记录的排序

  所以一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

  如果要返回的列是索引的一部分，那么这些记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，可以很快的把这些连着的记录从磁盘中读出来，这种读取方式称为`顺序I/O`。

  如果要返回的列不是索引的一部分，那么需要根据主键值进行回表操作获取数据。这些主键值可能并不相连，但是在聚簇索引中的记录是根据主键的顺序排列的，所以根据这些并不连续的主键值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，那么可能要访问更多的数据页，这种读取方式称为`随机I/O`。

  如果要回表的数据越多，性能越差，MySQL可能会偏向全表扫描。

- B+树索引适应的条件

  - 全值匹配

    查询条件中的列和索引列一致

    > 查询条件中列的顺序不一定要与索引列的顺序相同。因为MySQL查询优化器会自动进行匹配

  - 匹配左边的列

    如果查询语句想要利用联合索引来进行查询，查询的列必须是联合索引中最左边连续的列。

  - 匹配列前缀

  - 匹配范围值

    如果对多个列同时进行范围查找，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引

  - 精确匹配某一列并范围匹配另外一列

    如果精确匹配是最左边连续的列，则右边的列可以使用范围匹配

  - 排序

    用于`ORDER BY`的列顺序与索引列顺序一致，则可以直接从索引中取出数据，再进行回表操作取出索引中不包含的列的数据

  - 分组

    用于`GROUP BY`的列顺序与索引列顺序一致

- 使用索引时的注意事项：

  - 为用于查询、排序或分组的列创建索引

  - 为基数大的列创建索引

    列的值比较分散

  - 索引列的数据类型尽量小

    数据类型越小，索引占用的存储空间越少，查询时进行比较的操作较快

  - 可以只对字符串值的前缀建立索引

  - 只有索引列在比较表达式中单独出现才可以适用索引

  - 为了尽可能少的让`聚簇索引`发生页面分裂和记录移位的情况，让主键拥有`AUTO_INCREMENT`属性或者保证主键值是依次增大的

  - 删除表中的重复和冗余索引

  - 尽量使用`覆盖索引`进行查询，避免`回表`带来的性能损耗

    即查询的列就是索引列

---

##### 10 InnoDB的表空间

- 页面通用部分

  <div align="center">
    <img src="images/通用页结构.png" >
  </div>

  - `File Header`：记录页面的一些通用信息
  - `File Trailer`：校验页是否完整，保证从内存到磁盘刷新时内容的一致性

- `File Header`的各个组成部分

  | 名称                               | 占用空间大小 | 描述                                                         |
  | :--------------------------------- | :----------: | :----------------------------------------------------------- |
  | `FIL_PAGE_SPACE_OR_CHKSUM`         |   `4`字节    | 页的校验和（checksum值）                                     |
  | `FIL_PAGE_OFFSET`                  |   `4`字节    | 页号                                                         |
  | `FIL_PAGE_PREV`                    |   `4`字节    | 上一个页的页号                                               |
  | `FIL_PAGE_NEXT`                    |   `4`字节    | 下一个页的页号                                               |
  | `FIL_PAGE_LSN`                     |   `8`字节    | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
  | `FIL_PAGE_TYPE`                    |   `2`字节    | 该页的类型                                                   |
  | `FIL_PAGE_FILE_FLUSH_LSN`          |   `8`字节    | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
  | `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` |   `4`字节    | 页属于哪个表空间                                             |

  - `FIL_PAGE_OFFSET`为表空间中的每一个页对应的一个页号

    这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页。

    如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。

    表空间的第一个页的页号为0，之后的页号分别是1，2，3 ... 依此类推

  - `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`来存储上一个页和下一个页的页号

    这两个字段主要是为了`INDEX`类型的页，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的

  - `FIL_PAGE_TYPE`表示每个页的类型

    不同类型的页在该字段上的值是不同的，比如：数据页该字段的值就是`0x45BF`

- 什么是区（extent）

  对于16KB的页来说，连续的64个页就是一个`区`，也就是说一个区默认占用1MB空间大小。

  不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。

  <div align="center">
    <img src="images/表空间结构.png" >
  </div>

- 什么是组

  每256个区被划分成一组

  <div align="center">
    <img src="images/组的结构.png" >
  </div>

  - 第一个组最开始的3个页面的类型是固定的，也就是说`extent 0`这个区最开始的3个页面的类型是固定的，分别是：

    - `FSP_HDR`

      这个类型的页面是用来登记整个表空间的整体属性以及本组所有`区`的属性。

      整个表空间只有一个`FSP_HDR`类型的页面

    - `IBUF_BITMAP`

      这个类型的页面是存储本组所有区的所有页面关于`INSERT BUFFER`的信息

    - `INODE`

      这个类型的页面存储了许多称为`INODE`的数据结构

  - 其余各组最开始的2个页面的类型是固定的

    也就是说`extent 256`、`extent 512`等这些区最开始的2个页面的类型是固定的，分别是：

    - `XDES`（extent descriptor）

      用来登记本组256个区的属性。

      `FSP_HDR`类型的页面其实和`XDES`类型的页面的作用类似，只不过`FSP_HDR`类型的页面还会额外存储一些表空间的属性。

    - `IBUF_BITMAP`

- 碎片区（fragment）的作用是什么

  在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。

  碎片区直属于表空间，并不属于任何一个段。

  为某个段分配存储空间的策略如下：

  - 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的
  - 当某个段已经占用了32个碎片区的页面之后，就会以完整的区为单位来分配存储空间

- 什么是段

  段不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。

  叶子节点有自己独有的`区`，非叶子节点也有自己独有的`区`。

  存放叶子节点的区的集合就算是一个`段`（`segment`），存放非叶子节点的区的集合也算是一个`段`。

  也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段

- 段的结构

  <div align="center">
    <img src="images/段-INODE_Entry结构.png" >
  </div>

  - `Segment ID`

    表示这个`INODE Entry`结构对应的段的编号（ID）

  - `NOT_FULL_N_USED`

    表示在`NOT_FULL`链表中已经使用了多少个页面。

    下次从`NOT_FULL`链表分配空闲页面时可以直接根据这个字段的值定位到。而不用从链表中的第一个页面开始遍历着寻找空闲页面

  - `List Base Node`

    分别为段的`FREE`链表、`NOT_FULL`链表、`FULL`链表定义了`List Base Node`，当要查找某个段的某个链表的头节点和尾节点的时候，可以直接到这个部分找到对应链表的`List Base Node`

  - `Magic Number`

    用来标记这个`INODE Entry`是否已经被初始化了（即把各个字段的值都填进去了）。

    如果这个数字的值`97937874`，表明该`INODE Entry`已经初始化，否则没有被初始化

  - `Fragment Array Entry`

    每个`Fragment Array Entry`结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号

- 区的分类

  - 空闲的区

    现在还没有用到这个区中的任何页面

  - 有剩余空间的碎片区

    碎片区中还有可用的页面

  - 没有剩余空间的碎片区

    碎片区中的所有页面都被使用，没有空闲页面

  - 附属于某个段的区

    每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位

  这4种类型的区称为区的4种状态（State）:

  | 状态名      | 含义                 |
  | :---------- | :------------------- |
  | `FREE`      | 空闲的区             |
  | `FREE_FRAG` | 有剩余空间的碎片区   |
  | `FULL_FRAG` | 没有剩余空间的碎片区 |
  | `FSEG`      | 附属于某个段的区     |

  处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，直属于表空间。

  处于`FSEG`状态的区是附属于某个段的

- `XDES Entry`（Extent Descriptor Entry）

  用于对区进行管理，每一个区都对应着一个`XDES Entry`结构，这个结构记录了对应的区的属性

  <div align="center">
    <img src="images/XDES_Entry结构.png" >
  </div>

- `XDES Entry`的结构

  `XDES Entry`是一个40个字节的结构，分为4个部分：

  - `Segment ID`（8字节）

    每一个段都有一个唯一的编号，用ID表示，此处的`Segment ID`字段表示就是该区所在的段。

  - `List Node`（12字节）

    将若干个`XDES Entry`结构串联成一个链表

  - `State`（4字节）

    表示区的状态。即`FREE`、`FREE_FRAG`、`FULL_FRAG`和`FSEG`

  - `Page State Bitmap`（16字节）

    这个部分共占用16个字节，即128个比特位。

    一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。

    这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。

    比如：第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推

- `List Node`的结构

  <div align="center">
    <img src="images/List_Node结构.png" >
  </div>

  通过指定页号以及指定页号的页内偏移量即可定位表空间内的某一个位置：

  - `Pre Node Page Number`和`Pre Node Offset`的组合就是指向前一个`XDES Entry`的指针
  - `Next Node Page Number`和`Next Node Offset`的组合就是指向后一个`XDES Entry`的指针

- `List Node`的作用

  - 把状态为`FREE`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表被称为`FREE`链表
  - 把状态为`FREE_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表被称为`FREE_FRAG`链表
  - 把状态为`FULL_FRAG`的区对应的`XDES Entry`结构通过`List Node`来连接成一个链表，这个链表被称为`FULL_FRAG`链表

- 向段中插入数据的过程

  - 当段中数据较少的时候，首先会查看表空间中是否有状态为`FREE_FRAG`的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零碎的页把数据插进去；

    否则到表空间下申请一个状态为`FREE`的区，也就是空闲的区，把该区的状态变为`FREE_FRAG`，然后从该新申请的区中取一些零碎的页把数据插进去。

    之后不同的段使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了`FULL_FRAG`

  - 当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据

- 在向段中插入数据时，怎么知道表空间中处于各种状态的区

  找状态为`FREE_FRAG`的区时，直接把`FREE_FRAG`链表的头节点拿出来，从这个节点中取一些零碎的页来插入数据。

  当这个节点对应的区用完时，就修改一下这个节点的`State`字段的值，然后从`FREE_FRAG`链表中移到`FULL_FRAG`链表中。

  如果`FREE_FRAG`链表中一个节点都没有，那么就直接从`FREE`链表中取一个节点移动到`FREE_FRAG`链表的状态，并修改该节点的`State`字段值为`FREE_FRAG`，然后从这个节点对应的区中获取零碎的页

- 通过什么知道哪些区是属于哪个段

  - `FREE`链表

    同一个段中，所有页面都是空闲的区对应的`XDES Entry`结构会被加入到这个链表。

    > 注意和直属于表空间的`FREE`链表区别开了，此处的`FREE`链表是附属于某个段的。

  - `NOT_FULL`链表

    同一个段中，仍有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表

  - `FULL`链表

    同一个段中，已经没有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表

  每个索引都对应两个段，每个段都会维护这3个链表。

  段在数据量比较大时插入数据，会先获取`NOT_FULL`链表的头节点，直接把数据插入这个头节点对应的区中，如果该区的空间已经被用完，就把该节点移到`FULL`链表中

- `List Base Node`的结构

  `List Base Node`结构包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息。

  将链表对应的`List Base Node`结构放置在表空间中固定的位置，用于定位某个链表

  <div align="center">
    <img src="images/List_Base_Node结构.png" >
  </div>

  - `List Length`

    表明该链表一共有多少节点

  - `First Node Page Number`和`First Node Offset`

    表明该链表的头节点在表空间中的位置

  - `Last Node Page Number`和`Last Node Offset`

    表明该链表的尾节点在表空间中的位置
  
  

这章概念性的东西实在太多了，待续。。。

---

##### 11 单表访问方法

- const

  通过主键或者唯一二级索引列与常数的等值比较来定位一条记录

  > 唯一二级索引列并不限制 NULL 值的数量，所以使用NULL值查询时不是`const`

- ref

  通过二级索引列与常数等值比较来定位记录

  - 二级索引列值为`NULL`

    不管是普通的二级索引，还是唯一二级索引，它们的索引列对包含`NULL`值的数量并不限制，所以当采用`key IS NULL`这种形式的查询条件时，最多只能使用`ref`的访问方法

  - 包含多个索引列的二级索引

    只要最左边的连续索引列是与常数的等值比较就可能采用`ref`的访问方法。

    但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称之为`ref`

- ref_or_null

  不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为`NULL`的记录也找出来

- range

  索引列匹配某个或某些范围的值

- index

  查询的列在索引列中，但是又不是最左边的列，返回的列在索引列中，这种情况下的查询需要遍历二级索引记录

  > 因为二级索引记录比聚簇索记录小的多，而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多
  
- all

  直接扫描聚簇索引
  
- 索引合并
  一般情况下执行一个查询时最多只会用到单个二级索引，在某些特殊情况下可能一个查询中会使用到多个二级索引

  - Intersection合并（交集）

    查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集

    - 二级索引列是等值匹配。

      对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况

    - 主键列可以是范围匹配

      > 因为聚族索引是根据主键值排序的，所以即使是范围匹配返回的主键值也是有序的。而二级索引则不一定

  - Union合并
    二级索引列是等值匹配；

    对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况

    - 主键列可以是范围匹配
    - 使用`Intersection`索引合并的查询条件

  - Sort-Union合并

    先按照二级索引记录的主键值进行排序，之后按照`Union`索引合并的方式进行处理

---

##### 12 连接的原理

- `WHERE`子句中的过滤条件

  不论是内连接还是外连接，凡是不符合`WHERE`子句中的过滤条件的记录都不会被加入最后的结果集

- `ON`子句中的过滤条件

  对于外连接的驱动表的记录来说，如果无法在`被驱动表`中找到匹配`ON`子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用`NULL`值填充。

  > 需要注意的是，这个`ON`子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的。
  >
  > 所以如果把`ON`子句放到内连接中，`MySQL`会把它和`WHERE`子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的

- 两表连接查询的过程（嵌套循环连接（Nested-Loop Join））

  - 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询
  - 对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录

- 加快多表连接的速度

  - 使用索引
  - 基于块的嵌套循环连接（Block Nested-Loop Join）

- 基于块的嵌套循环连接（Block Nested-Loop Join）

  执行连接查询前申请一块固定大小的内存 — `join buffer`，先把若干条驱动表结果集中的记录装在这个`join buffer`中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和`join buffer`中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的`I/O`代价

  <div align="center">
    <img src="images/基于块的嵌套连接.png" >
  </div>

  驱动表的记录并不是所有列都会被放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中，所以最好不要把`*`作为查询列表

  > `join buffer`的大小是可以通过启动参数或者系统变量`join_buffer_size`进行配置，默认大小为`262144字节`（`256KB`），最小可以设置为`128字节`

---

##### 13 基于查询的成本

- 基于成本的优化步骤
  - 根据搜索条件，找出所有可能使用的索引
  - 计算全表扫描的代价
  - 计算使用不同索引执行查询的代价
  - 对比各种执行方案的代价，找出成本最低的那一个



关于成本的具体计算细节，先余着 。。。

---

##### 14 InnoDB 统计数据是如何收集的

余着 。。。

---

##### 15 基于规则的优化

- 移除不必要的括号

- 常量传递

  ```mysql
  a = 5 AND b > a  ==>  a = 5 AND b > 5
  ```

- 等值传递

  ```mysql
  a = b and b = c and c = 5  ==>  a = 5 and b = 5 and c = 5
  ```

- 移除没用的条件

- 表达式计算

  ```mysql
  a = 5 + 1  ==>  a = 6
  ```

  > 优化器不会对出现在表达式中的列做计算
  
  关于子查询的优化先余着 。。。

##### 16 Explain详解

- `EXPLAIN`语句输出的各个列

  |      列名       | 描述                                                       |
  | :-------------: | :--------------------------------------------------------- |
  |      `id`       | 在一个大的查询语句中每个`SELECT`关键字都对应一个唯一的`id` |
  |  `select_type`  | `SELECT`关键字对应的那个查询的类型                         |
  |     `table`     | 表名                                                       |
  |  `partitions`   | 匹配的分区信息                                             |
  |     `type`      | 针对单表的访问方法                                         |
  | `possible_keys` | 可能用到的索引                                             |
  |      `key`      | 实际上使用的索引                                           |
  |    `key_len`    | 实际使用到的索引长度                                       |
  |      `ref`      | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息     |
  |     `rows`      | 预估的需要读取的记录条数                                   |
  |   `filtered`    | 某个表经过搜索条件过滤后剩余记录条数的百分比               |
  |     `Extra`     | 一些额外的信息                                             |

- table

  `EXPLAIN`语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名

- id

  查询语句中每出现一个`SELECT`关键字，就会配一个唯一的`id`值。

  一个`SELECT`关键字后边的`FROM`子句中可以跟随多个表，每个表都会对应一条记录，但是这些记录的id值都是相同的。

  对于包含子查询的查询语句来说，可能涉及多个`SELECT`关键字，所以每个`SELECT`关键字都会对应一个唯一的`id`值。

  > 但是查询优化器可能子查询的查询语句进行重写，从而转换为连接查询，那么`id`就都是一样的了

  对于包含`UNION`子句的查询语句来说，`id`为`NULL`表明这个临时表是为了合并两个查询的结果集而创建的，因为需要去重。

  对于`UNION ALL`来说，则不会这样，因为它不需要为最终的结果集进行去重

- select_type

  - SIMPLE

    查询语句中不包含`UNION`或者子查询的查询都算作是`SIMPLE`类型

  - PRIMARY

    对于包含`UNION`、`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的`select_type`值就是`PRIMARY`

  - UNION

    对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的`select_type`值就是`UNION`

  - UNION RESULT

    使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是`UNION RESULT`

  - 。。。

- type

  - system

    当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory

  - const

    根据主键或者唯一二级索引列与常数进行等值匹配时

  - eq_ref

    在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的

  - ref

    当通过普通的二级索引列与常量进行等值匹配时来查询某个表

  - fulltext

    全文索引

  - ref_or_null

    当对普通二级索引进行等值匹配查询，该索引列的值也可以是`NULL`值时

  - index_merge

    使用`Intersection`、`Union`、`Sort-Union`这三种索引合并的方式来执行查询

  - unique_subquery

    在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配

  - index_subquery

    与`unique_subquery`类似，只不过访问子查询中的表时使用的是普通的索引

  - range

    使用索引获取某些`范围区间`的记录时

  - index

    使用索引覆盖，但需要扫描全部的索引记录时

  - ALL

    全表扫描


- possible_keys、key

  在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，`key`列表示实际用到的索引有哪些

- key_len

  当优化器决定使用某个索引执行查询时，该索引记录的最大长度：

  - 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值。

    对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是`VARCHAR(100)`，使用的字符集是`utf8`，那么该列实际占用的最大存储空间就是`100 × 3 = 300`个字节

  - 如果该索引列可以存储`NULL`值，则`key_len`比不可以存储`NULL`值时多1个字节

  - 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度

- ref

  当使用索引列等值匹配的条件去执行查询时，`ref`列展示的就是与索引列作等值匹配是什么，比如只是一个常数或者是某个列

  > ref的值为`const`时表示是常数

- rows

  预计扫描的记录行数

- filtered

  计算驱动表扇出时需要估计出满足查询条件的记录到底有多少条

- Extra

  - No tables used

    当查询语句的没有`FROM`子句时将会提示该额外信息

  - Impossible WHERE

    查询语句的`WHERE`子句永远为`FALSE`时将会提示该额外信息

  - No matching min/max row

    当查询列表处有`MIN`或者`MAX`聚集函数，但是并没有符合`WHERE`子句中的搜索条件的记录时

  - Using index

    当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下时

  - Using index condition

    通过索引列的查询条件查出来的数据先不着急回表，而是对其他无法使用索引列的条件进行过滤，之后再回表，这样就减少了回表查询随机I/O的次数

    > SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';

  - Using where

    使用全表扫描来执行对某个表的查询，并且该语句的`WHERE`子句中有针对该表的搜索条件时

  - Using join buffer (Block Nested Loop)

    在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，`MySQL`一般会为其分配一块名叫`join buffer`的内存块来加快查询速度，即`基于块的嵌套循环算法`

  - Not exists

    在使用外连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的查询条件，而且那个列又是不允许存储`NULL`值时

  - Using intersect(...) / Using union(...) / Using sort_union(...)

    说明使用了索引合并

  - Zero limit

    当`LIMIT`子句的参数为`0`时

  - Using filesort

    当某个查询需要在内存中或者磁盘上进行排序时

  - Using temporary

    当查询中使用到了内部的临时表时

    > `MySQL`会在包含`GROUP BY`子句的查询中默认添加上`ORDER BY`子句
    >
    > 如果并不想为包含`GROUP BY`子句的查询进行排序，需要显式的写上`ORDER BY NULL`

---

##### 19 InnoDB的Buffer Pool

InnnoDB为了缓存磁盘中的页，在`MySQL`服务器启动的时候就向操作系统申请了一片连续的内存，叫做`Buffer Pool`（缓冲池）。

默认情况下`Buffer Pool`只有`128M`大小，最小值为`5M`(当小于该值时会自动设置成`5M`)

- Buffer Pool内部组成
  Buffer Pool中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是16KB
  
  <div align="center">
    <img src="images/Buffer_Pool内部组成.png" >
  </div>
  
  每个控制块与缓存页一一对应。控制块包含了每个页对应的控制信息。
  
  分配完控制块与缓存页之后，剩余的空间不够分配一对控制块和缓存页时，就成了碎片
  
- free链表管理

  把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，即`free链表`。

  刚刚完成初始化的`Buffer Pool`中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到`free链表`中

  <div align="center">
    <img src="images/free链表.png" >
  </div>

  `基节点`包含了链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息

  > 链表的基节点占用的内存空间并不包含在为`Buffer Pool`申请的一大片连续内存空间之内，而是单独申请的一块内存空间。

  每当需要从磁盘中加载一个页到`Buffer Pool`中时，就从`free链表`中取一个空闲的缓存页，并且把该缓存页对应的`控制块`的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的`free链表`节点从链表中移除，表示该缓存页已经被使用了

- 怎么知道页在不在Buffer Pool中

  用`表空间号 + 页号`作为`key`，`缓存页`作为`value`创建一个哈希表

- flush链表管理

  如果修改了`Buffer Pool`中某个缓存页的数据，就和磁盘上的页不一致了，这样的缓存页也被称为`脏页`（`dirty page`）。

  > 每次修改缓存页后，并不立即把修改同步到磁盘上，而是在未来某个时间点同步

  把修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，即`flush链表`。构造与`free链表	`差不多。

  <div align="center">
    <img src="images/flush链表.png" >
  </div>

- 预读（read ahead）

  `InnoDB`认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到`Buffer Pool`中。

  - 线性预读

    如果顺序访问了某个区（`extent`）的页面超过这个全局系统变量`innodb_read_ahead_threshold`的值（默认为56）。

    则会异步读取下一区中全部的页面到Buffer Pool中

  - 随机预读

    如果`Buffer Pool`中已经缓存了某个区13个连续的页面，不论这些页面是不是顺序读取的，都会`异步`读取本区中所有其他的页面到`Buffer Pool`。

    可以通过全局变量`innodb_random_read_ahead`来控制是否开启，默认为`OFF`

- 使用LRU链表管理Buffer Pool

  - 为了防止加载到Buffer Pool中的数据不一定用得到，所以将LRU链表分成两截：
    - 一部分存储使用频率非常高的缓存页，叫做`热数据`，或者称`young区域`
    - 另一部分存储使用频率不是很高的缓存页，叫做`冷数据`，或者称`old区域`

    每次加载数据到Buffer Pool中时，先放到`old`区域，第二次再访问时放到`young`区。

    可以通过全局系统变量`innodb_old_blocks_pct`来设置两个区域的占比。默认值为`37`，即`old`占用37%

  - 为了防止非常多的低频率使用的数据加载到Buffer Pool，给缓存页加个访问时间，如果在后续的访问时间与第一次的访问时间在某个时间间隔内，那么该数据就不会放入`young`区。

    间隔时间由系统变量`innodb_old_blocks_time`控制，默认值`1000`，即1000ms

  - 为了减少频繁移动young区域的头节点

    只有被访问的缓存页位于`young`区`1/4`的后边，才会被移动到LRU链表头部

---

##### 20 事务简介

- 事务的四个特性是：

  - 原子性（Atomicity）
  - 隔离性（Isolation）
  - 一致性（Consistency）
  - 持久性（Durability）

- 事务的四个状态：

  - 活动的（active）

    事务对应的数据库操作正在执行过程中时

  - 部分提交的（partially committed）

    当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时

  - 失败的（failed）

    当事务处在`活动的`或者`部分提交的`状态时，遇到错误而无法继续执行，或者人为的停止当前事务的执行时

  - 中止的（aborted）

    如果事务变为`失败的`状态，需要撤销失败事务对当前数据库造成的影响，这个撤销的过程称之为`回滚`。

    当`回滚`操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了`中止的`状态

  - 提交的（committed）

    当一个处在`部分提交的`状态的事务将修改过的数据都同步到磁盘上之后时

  当事务处于提交的或者中止的状态时，一个事务的生命周期才算结束

- 开启事物

  - `BEGIN [WORK]`

    > `WORK`可有可无

  - `START TRANSACTION`

    - 设置访问模式

      - `READ ONLY`

        标识当前事物是一个只读事物

      - `READ WRITE`

        标识当前事物是一个读写事物

      - `WITH CONSISTENT SNAPSHOT`

        启动一致性读

    可以使用`逗号`分割来指定多个访问模式，但是`只读`与`读写`只能存其一。

    如果不显式指定事物的访问模式，则默认为`读写`模式。

  只有`InnoDB`和`NDB`存储引擎支持事务功能

- 提交事物

  `COMMIT [WORK]`

- 手动中止并回滚一个事物

  `ROLLBACK [WORK]`

- 自动提交

  - 查看自动提交是否开启

    `show variables like 'autocommit'`

    默认值为`ON`。即每一条语句都是一个独立的事物

  - 关闭自动提交

    - 显式的使用`start transaction`或`begin`语句开启一个事物，那么在本次事物提交或者回滚前会暂时关闭自动提交功能

    - 将系统变量`autocommit`的值设置为`OFF`

- 隐式提交

  在关闭了自动提交后，执行某些特殊的语句会导致事物提交的情况时

  - 定义或修改数据库对象的数据定义语言（Data definition language，DDL）

    数据库对象指的是数据库、表、视图、存储过程等。

    当使用`create`、`alter`、`drop`等语句去修改数据库对象时，会隐式提交已经输入语句的事物

  - 修改`MySQL`数据库中的表

    当使用`alter user`、`create user`、`drop user`、`grant`、`rename user`、`revoke`、`set password`等语句时会进行隐式提交

  - 事务控制或锁定相关的语句

    - 当一个事务还没提交或者回滚时，又使用了`start transaction`或`begin`语句开启了另一个事务时，会提交上一个事务
    - 当前`autocommit`系统变量的值为`OFF`，手动设置为`ON`时，会提交上一个事务
    - 使用`lock tables`、`unlock tables`等锁定相关的语句时，会提交上一个事务

  - 加载数据的语句

    使用`load data`语句批量往数据库导入数据时，会提交上一个事务

  - 关于`MySQL`复制的语句

    使用`start slave`、`stop slave`、`reset slave`、`change master to`等语句时，会提交上一个事务

  - 其他语句

    使用`ANALYZE TABLE`、`CACHE INDEX`、`CHECK TABLE`、`FLUSH`、 `LOAD INDEX INTO CACHE`、`OPTIMIZE TABLE`、`REPAIR TABLE`、`RESET`等语句时会提交上一个事务

- 保存点

  在事务对应的数据库语句中打点，在调用`rollback`语句时可以指定回滚到哪个点，而不是回到最初的原点

  - 定义保存点

    ```mysql
    savepoint 保存点名称;
    ```

  - 回滚到指定保存点

    ```mysql
    rollback [work] to [savepoint] 保存点名称;
    ```

  - 删除保存点

    ```mysql
    release savepoint 保存点名称;
    ```

---

##### 21 redo日志

- 什么是redo日志

  事务提交时，将本次事物所做的修改进行记录。在系统奔溃或者重启时，可以根据这些记录恢复数据

- redo日志的优点

  - 占用空间小
  - 顺序写入磁盘的

- redo日志通用结构

  ![](images/redo日志通用结构.png)

  - `type`

    redo日志的类型

  - `space ID`

    表空间ID

  - `page number`

    页号

  - `data`

    redo日志的具体内容

- 以组的形式写入redo日志

  语句在执行过程中可能修改若干个页面，由于对这些页面的更改都发生在`Buffer Pool`中，所以在修改完页面之后，需要记录一下相应的`redo`日志。

  在执行语句的过程中产生的`redo`日志被划分成了若干个不可分割的组。在进行系统崩溃重启恢复时，针对某个组中的`redo`日志，要么把全部的日志都恢复掉，要么一条也不恢复。

  > 向某个索引对应的`B+`树中插入一条记录的过程必须是原子的，执行这些需要保证原子性的操作时必须以`组`的形式来记录的`redo`日志。

- 怎么保证以组的形式写入的redo日志是完整的

  在该组中的最后一条`redo`日志后边加上一条特殊类型的`redo`日志。

  该类型名称为`MLOG_MULTI_REC_END`，`type`字段对应的十进制数字为`31`。

  该类型的`redo`日志结构很简单，只有一个`type`字段：

  ![](images/MLOG_MULTI_REC_END类型的redo日志.png)

  - 如果一个组里有多条redo日志

    需要保证原子性的操作产生的一系列`redo`日志必须要以一个类型为`MLOG_MULTI_REC_END`结尾

    ![](images/一条完整的redo日志.png)

  - 如果只有一条redo日志

    > 更新`Max Row ID`属性的操作就只会生成一条`redo`日志

    如果`type`字段的第一个比特位为`1`，代表该需要保证原子性的操作只产生了单一的一条`redo`日志，否则表示该需要保证原子性的操作产生了一系列的`redo`日志

    ![](images/redo-type字段.png)

- Mini-Transaction

  对底层页面中的一次原子访问的过程。简称`mtr`。

  > 一个事务可以包含若干条语句，每一条语句其实是由若干个`mtr`组成，每一个`mtr`又可以包含若干条`redo`日志

- redo log block

  把通过`mtr`生成的`redo`日志都放在了大小为`512字节`的`页`中。

  ![](images/redo-log-block.png)

- redo日志缓冲区

  服务器启动时会向操作系统申请了一大片称之为`redo log buffer`的连续内存空间。这片内存空间被划分成若干个连续的`redo log block`

  ![](images/redo-log-buffer.png)

  每个`mtr`运行过程中产生的日志先暂时存到一个地方，当该`mtr`结束的时候，将这个过程中产生的一组`redo`日志再全部复制到`log buffer`中

- redo日志刷盘时机

  - `log buffer`空间不足时
  - 事务提交时
  - 后台线程刷新
  - 正常关闭服务器时
  - 做的`checkpoint`时

- redo日志文件组

  MySQL的数据目录下，默认有两个名为`ib_logfile0`和`ib_logfile1`的文件，log buffer中的日志默认情况下就是刷新到这两个文件中。

  这些日志文件被称为`日志文件组`

- redo日志文件格式

  与`log buffer`类似，由若干个`512`字节大小的block组成

- （日志序列号）Log Sequence Number

  redo日志不断生成，为了记录已经写入的redo日志量。简称`lsn`。

  `lsn`是全局变量，初始值为`8704`

  `lsn`增长的量就是该`mtr`生成的redo日志占用的字节数

  > 大致这么理解就好了，不必扣细节

  每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早

- flush链表中的LSN

  在mtr执行过程中修改过的页面需要加入到Buffer Pool的flush链表中。

  当第一次修改某个缓存在Buffer Pool中的页面时，就会把这个页面对应的控制块插入到flush链表的头部，之后再修改该页面时由于它已经在flush链表中了，就不再次插入了。

  也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。

  缓存页对应的控制块中有两个关于页面何时修改的属性：

  - `oldest_modification`

    如果某个页面被加载到`Buffer Pool`后进行第一次修改，那么就将修改该页面的`mtr`**开始时**对应的`lsn`值写入这个属性

  - `newest_modification`

    每修改一次页面，都会将修改该页面的`mtr`**结束时**对应的`lsn`值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统`lsn`值

  ![](images/flush链表中的lsn.png)

  > 先更新a，再更新b跟c，再更新b跟d

- checkpoint

  `redo`日志文件组容量是有限的，我们不得不选择循环使用`redo`日志文件组中的文件，但是这会造成最后写的`redo`日志会覆盖最开始写的`redo`日志。
  
  所以需要判断某些redo日志对应的脏页是否已经刷新到磁盘里，即占用的磁盘空间是否可以覆盖
  
  InnoDB使用一个全局变量`checkpoint_lsn`来代表当前系统中可以被覆盖的redo日志总量是多少，这个变量初始值也是8704。
  
  当某个页被刷新到磁盘，表示该页对应的redo日志可以被覆盖了，则对checkpoint_lsn做增加操作。这个过程称之做一次**checkpoint**。
  
- redo日志刷盘策略

  通过系统变量`innodb_flush_log_at_trx_commit`控制：

  - **0**：

    表示在事务提交时不立即向磁盘中同步`redo`日志，这个任务是交给后台线程做的。

    会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将`redo`日志刷新到磁盘，那么该事务对页面的修改会丢失

  - **1**

    默认。表示在事务提交时需要将`redo`日志同步到磁盘，可以保证事务的`持久性`

  - **2**

    表示在事务提交时需要将`redo`日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。

    这种情况下如果数据库挂了，操作系统没挂的话，事务的`持久性`还是可以保证的，但是操作系统也挂了的话，那就不能保证`持久性`了。

- 崩溃恢复

  - 确定恢复的起点

    从redo日志文件组的读取最近发生的`checkpoint`时对应的`checkpoint_lsn`值以及它在`redo`日志文件组中的偏移量`checkpoint_offset`

  - 确定恢复的终点

    redo日志都是顺序写的，写满了一个block之后会再往下一个block中写。

    block的`log block header`部分有一个称之为`LOG_BLOCK_HDR_DATA_LEN`的属性，该属性值记录了当前block里使用了多少字节的空间。

    对于被填满的block来说，该值永远为`512`。如果该属性的值不为`512`，那么它就是此次崩溃恢复中需要扫描的最后一个block

  - 怎么恢复

    按照`redo`日志的顺序依次扫描`checkpoint_lsn`之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来

---

##### 22 undo日志

每当对记录做改动时，为了回滚需要记录下来。

- 给事务分配id的时机

  如果某个事务执行过程中对某个表执行了增、删、改操作，那么`InnoDB`存储引擎就会给它分配一个独一无二的`事务id`

  - 对于只读事务来说，只有在它第一次对某个**用户创建的临时表**执行增、删、改操作时才会为这个事务分配一个`事务id`

    > `CREATE TEMPORARY TABLE`

  - 对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个`事务id`

  

































