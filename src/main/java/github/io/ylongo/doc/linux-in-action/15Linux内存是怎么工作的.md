# 15 Linux内存是怎么工作的

## 内存映射

我们通常所说的内存容量，其实指的是物理内存。物理内存也被称为主存。大多数计算机用的内存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。

进程需要访问内存时，Linux内核给每个进程提供了一个独立的虚拟地址空间，这个空间是连续的。

虚拟地址空间又分为：**内核空间**和**用户空间**。

不同字长（单个CPU指令可以处理数据的最大长度）的处理器，地址空间的范围不同。

32位与64位系统的虚拟地址空间范围如下：

<div align="center">
  <img src="images/地址空间的范围.png"/>
</div>

> 32位系统的内核空间占`1G`，位于最高处，用户空间占`3G`
>
> 64位系统的内核空间与用户空间都是占`128T`，分别占整个内存空间的最高与最低处，剩下的中间部分为未定义。

进程在用户态时，只能访问用户空间内存。只有进入内核态后，才可以访问内核空间内存。

每个进程地址空间中的内核空间关联的都是相同的物理内存，切换到内核态后，就可以访问内核空间内存。

每个进程的虚拟内存加起来比实际内存要大得多，所以并不是所有的虚拟内存都会分配物理内存，只有实际使用的虚拟内存才会分配物理内存，这些分配后的物理内存，是通过**内存映射**来管理的。

内存映射：将**虚拟内存地址**映射到**物理内存地址**。

为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系。如下：

<div align="center">
  <img src="images/内存映射.png" />
</div>

页表存储在CPU的内存管理单元`MMU`中，处理器可以直接通过硬件找到要访问的内存。

当进程访问的虚拟地址在页表中查不到时，就会产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，然后返回用户空间，恢复进程的运行。

> Linux通过`TLB`（Translation Lookaside Buffer，后备缓冲器）来管理虚拟内存到物理内存之间的映射关系，它其实就是`MMU`中页表的高速缓存。
>
> 由于进程的虚拟地址空间是独立的，而`TLB`的访问速度比`MMU`快得多。当虚拟内存更新后，`TLB`也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

`MMU`以页为内存映射的最小单位来管理内存，大小一般为`4KB`。每一次内存映射，都需要关联`4KB`整数倍的内存空间。

页的大小只有`4KB`，会导致整个页表变得很大。

> 在32位的系统上需要100万（4GB/4KB）个页表项才可以实现整个地址空间的映射

Linux提供了**多级页表**与**大页（HugePage）**这两种机制来解决这个问题。

多级页表把内存分成区块来管理，将原来的映射关系变成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少的一部分，多级页表就只保存使用中的区块，这样就大大减少了页表的项数。

Linux使用四级页表来管理内存页，虚拟地址被分为5个部分，前4个用于选择页，最后一个表示页内偏移，如下：

<div align="center">
  <img src="images/多级页表.png" />
</div>

大页是比普通页更大的内存块，通常为`1MB`与`1GB`。大页用于使用大量内存的进程上。

## 虚拟内存空间分布

用户空间内存被分成了多个不同的段，32位系统的分布如下图：

<div align="center">
  <img src="images/虚拟内存空间分布.png" />
</div>

1. 只读段：包括代码和常量等
2. 数据段：包括局部变量等
3. 堆：包括动态分配的内存，从低地址向上增长
4. 文件映射段：包括动态库、共享内存等，从高向下增长
5. 栈：包括局部变量和函数调用的上下文等。栈的大小一般固定为`8MB`

堆和文件映射段的内存是动态分配的。

> 使用C标准库中的`malloc()`和`mmap()`
>
> 64位系统的内存分布类似，只不过内存空间要大很多

## 内存的分配与回收

`malloc()`对应到系统调用有两种方式：

- `brk()`：分配小块内存（小于128K），通过移动堆顶的位置来分配内存。这些内存释放后不会立刻归还系统，而是被缓存起来再重复利用。

  可以减少缺页异常的发生，提高内存访问效率。由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片

- `mmap()`：分配大块内存（大于128K），在文件映射段找一块空闲内存分配出去。

  分配的内存释放时会归还系统，所以`mmap`每次都会发生缺页异常。在内存频繁工作时，频繁的内存分配会导致大量的缺页异常，使内核管理负担增大。

当两种调用发生后，并没有真正分配内存，只有在首次访问时才分配，也就是通过缺页异常进入内核中，再由内核来分配内存。

如果只分配而不释放，则会造成内存泄漏，所以在应用程序用完内存后，调用`free()`或`unmap()`进行释放。

在内存紧张时，系统会通过一系列机制来回收内存：

- 回收缓存：回收掉最近最少使用的内存页面

- 回收不常访问的内存：把不常用的内存通过交换分区直接写到磁盘中

  通过交换分区（`swap`）来进行回收。`swap`把一块磁盘空间当作内存使用。把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（换入）

  > 通常在内存不足时才会发生`swap`，虽然把系统的可用内存变大了，但是由于磁盘读写速度远比内存慢，会导致严重的内存性能问题

- 通过`OOM`杀死进程：直接杀掉占用大量内存的进程

  使用`oom_score`为每个进程的内存使用情况进行评分，分数越高，越容易被杀死。

  - 一个进程消耗的内存越大，`oom_socre`越大
  - 一个进程占用的CPU越多，`oom_score`越小

  可以在`/proc`来设置进程的`oom_adj`来调整`oom_score`

  `oom_adj`的范围是`[-17, 15]`，数值越大表示进程越容易被`OOM`杀死，越小表示越不容易。`-17`表示禁止`OOM`

  

